# AQS整理

AQS（AbstractQueuedSynchronizer）是一个用于实现各种同步器的抽象类，是 JUC（java.util.concurrent）并发包中的核心类之一，JUC 中的许多并发工具类和接口都是基于 AQS 实现的。  
它提供了一种基于队列的、高效的、可扩展的同步机制，是实现锁、信号量、倒计时器等同步器的基础.它使用了一个int成员变量state来表示同步的状态，并内置了一个队列来完成需要获取资源的线程的排队工作；  
锁是面向锁的使用者的，而AQS则是面向锁的编写者的,这个FIFO的双向队列是基于CLH单向链表实现的，我们通过包含显式的（"prev" 和 "next"）链接以及一个"status"字段，将其用于阻塞同步器，这些字段允许节点在释放锁时向后续节点发送信号，并处理由于中断和超时导致的取消操作。


> 同步器：同步器指的是用于控制多线程访问共享资源的机制。同步器可以保证在同一时间只有一个线程可以访问共享资源，从而避免了多线程访问共享资源时可能出现的数据竞争和不一致性问题。Java 中的同步器包括 **synchronized** 关键字、**ReentrantLock**、**Semaphore**、**CountDownLatch** 等。

AQS的工作原理是什么？

三个组件：state，队列，exclusiveOwnerThread  
**state**：实现锁信息的同步  
**CLH队列**：对获取锁失败的线程进行管理  
**exclusiveOwnerThread**：用于表示当前是哪个线程正在持有锁  
  
AQS依赖底层的同步队列，当一个线程获取锁失败之后，那么就会将其封装为一个node节点然后到队列的末尾，并阻塞这个线程，当持有锁的线程释放之后，会将队头的节点中的线程唤醒，使其再次尝试获取锁

AQS的node节点的状态值有哪些？

- cancelled：节点引用的线程由于等待超时或者打断被取消之后，节点会变成cancelled状态
- signal：后续节点需要被唤醒时，当前节点就会变成signal状态，
- condition：表示当前节点进入了condition队列的状态
- propagate：释放共享锁的时候会头节点使用
